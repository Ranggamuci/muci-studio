import { GoogleGenAI, GenerateContentResponse, Modality, Type } from "@google/genai";
import { adatInspirations, maleClothing, femaleClothingHijab, femaleClothingNoHijab } from "../creativeData";
import { shuffleArray } from "../utils";
// FIX: Import `WomanStyle` to be used in function signatures, allowing for all possible style options.
import { ApiKeyStatus, OutfitIdea, CreativeBrief, FullCreativeConcept, IdentityAnchorFile, WomanStyle, GenerationDetails } from "../types";

const checkForSafetyBlock = (response: GenerateContentResponse) => {
    if (response.candidates && response.candidates.length > 0) {
        const firstCandidate = response.candidates[0];
        if (firstCandidate.finishReason && firstCandidate.finishReason !== 'STOP') {
             // Example finishReasons: "SAFETY", "RECITATION", "OTHER"
            return `Generation stopped: ${firstCandidate.finishReason}. Check safety ratings for details.`;
        }
    }
    return null;
}

/**
 * Generates an image from a text prompt, optionally using a reference image, using the Gemini Flash model.
 * @param apiKey The API key to use for this request.
 * @param prompt The detailed text prompt for image generation.
 * @param imageParts An array of base64 encoded reference images (optional).
 * @returns A promise that resolves to a base64 encoded image URL.
 */
export async function generateImage(apiKey: string, prompt: string, imageParts?: {base64: string, mimeType: string}[]): Promise<string> {
    try {
        const ai = new GoogleGenAI({ apiKey });

        const parts: ({ text: string } | { inlineData: { data: string; mimeType: string; } })[] = [];

        if (imageParts && imageParts.length > 0) {
            for (const img of imageParts) {
                 parts.push({ inlineData: { data: img.base64, mimeType: img.mimeType } });
            }
        }
        parts.push({ text: prompt });

        const response: GenerateContentResponse = await ai.models.generateContent({
            // FIX: Updated model name and responseModalities per Gemini API guidelines for image generation.
            model: 'gemini-2.5-flash-image',
            contents: { parts },
            config: {
                responseModalities: [Modality.IMAGE],
            },
        });

        const safetyBlockReason = checkForSafetyBlock(response);
        if (safetyBlockReason) {
            throw new Error(`SAFETY_BLOCK: ${safetyBlockReason}`);
        }

        for (const part of response.candidates[0].content.parts) {
            if (part.inlineData && part.inlineData.mimeType.startsWith('image/')) {
                const base64ImageBytes: string = part.inlineData.data;
                const imageMimeType = part.inlineData.mimeType;
                return `data:${imageMimeType};base64,${base64ImageBytes}`;
            }
        }

        const errorText = response.text?.trim();
        if (errorText) {
            throw new Error(`API returned a text response instead of an image: ${errorText}`);
        }
        
        throw new Error('No image was generated by the API.');

    } catch (error) {
        console.error("Error generating image with AI API:", error);
        if (error instanceof Error && error.message.startsWith('SAFETY_BLOCK:')) {
            throw error;
        }
        throw new Error(`Failed to generate image: ${error instanceof Error ? error.message : String(error)}`);
    }
}


/**
 * Generates a text response from a text prompt.
 * @param apiKey The API key to use for this request.
 * @param prompt The text prompt for text generation.
 * @returns A promise that resolves to the generated text string.
 */
export async function generateText(apiKey: string, prompt: string): Promise<string> {
    try {
        const ai = new GoogleGenAI({ apiKey });

        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: prompt,
        });

        const safetyBlockReason = checkForSafetyBlock(response);
        if (safetyBlockReason) {
            throw new Error(`SAFETY_BLOCK: ${safetyBlockReason}`);
        }

        const text = response.text;
        if (!text) {
            throw new Error("API returned an empty text response.");
        }
        return text.trim();

    } catch (error) {
        console.error("Error generating text with AI API:", error);
        if (error instanceof Error && error.message.startsWith('SAFETY_BLOCK:')) {
            throw error;
        }
        throw new Error(`Failed to generate text: ${error instanceof Error ? error.message : String(error)}`);
    }
}

/**
 * Creates a detailed, consistent physical description of a couple (faces, hair, build) to be reused across multiple images.
 * @param apiKey The API key to use for this request.
 * @param userPrompt The user's initial, basic description.
 * @param womanStyle The user's preference for the woman's style (hijab or no-hijab).
 * @returns A promise that resolves to a detailed and consistent couple description string.
 */
// FIX: Changed `womanStyle` parameter type to `WomanStyle` to accept all possible options from the UI.
export async function generateConsistentCoupleDescription(apiKey: string, userPrompt: string, womanStyle: WomanStyle): Promise<string> {
    try {
        const ai = new GoogleGenAI({ apiKey });

        let styleInstruction = '';
        if (womanStyle === 'Berhijab') {
            styleInstruction = 'The woman is described as wearing a hijab.';
        } else if (womanStyle === 'Tanpa Hijab') {
            styleInstruction = 'The woman is described as not wearing a hijab, and her hair should be visible and styled.';
        }

        const prompt = `From the user's prompt, create a detailed, consistent physical description of a young Indonesian couple's FACES and PHYSICAL APPEARANCE ONLY.
**Crucially, ensure authentic Indonesian features (skin tone, hair, facial structure). Do not describe Caucasian features.**
${styleInstruction}
Focus ONLY on specific, consistent facial features, hairstyle (or hijab style), skin tone, and build.
**DO NOT describe any clothing, outfits, or accessories.**
Output a single, cohesive paragraph describing only the couple's physical appearance.
User's prompt: "${userPrompt}"`;
        
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: prompt,
        });
        
        const safetyBlockReason = checkForSafetyBlock(response);
        if (safetyBlockReason) {
            throw new Error(`SAFETY_BLOCK: ${safetyBlockReason}`);
        }

        const text = response.text;
        if (!text) {
            throw new Error("API returned an empty text response while creating couple description.");
        }
        return text.trim();

    } catch (error) {
        console.error("Error generating consistent couple description:", error);
        if (error instanceof Error && error.message.startsWith('SAFETY_BLOCK:')) {
            throw error;
        }
        throw new Error(`Failed to generate couple description: ${error instanceof Error ? error.message : String(error)}`);
    }
}

/**
 * Generates a batch of creative, location-specific scenarios for a photoshoot.
 * @param apiKey The API key to use for this request.
 * @param locationTheme The theme of the photoshoot location (e.g., "Bromo", "Paris", "Studio Minimalis").
 * @param count The number of unique scenarios to generate.
 * @returns A promise that resolves to an array of scenario objects.
 */
export async function generateLocationBasedScenarios(apiKey: string, locationTheme: string, count: number): Promise<{ scene: string; emotion: string }[]> {
    try {
        const studioThemes = [
            "Studio Minimalis (Latar Putih)",
            "Studio Latar Warna Solid",
            "Studio Konsep Bohemian",
            "Studio Tema Bunga & Tanaman",
            "Studio Industrial (Dinding Bata)",
            "Studio Konsep Rumahan (Cozy)",
            "Studio Tema Vintage & Retro",
            "Studio Gelap & Moody (Low Key)",
            "Studio dengan Properti Unik",
            "Studio Proyeksi & Neon Light"
        ];
        const isStudioTheme = studioThemes.includes(locationTheme);

        let prompt: string;

        if (isStudioTheme) {
            prompt = `You are an elite photoshoot director. Generate ${count} unique, romantic, and story-driven photo scenarios for a photoshoot in a studio with the theme "${locationTheme}".

**CRITICAL RULE 1: AVOID MONOTONY.** You are explicitly forbidden from generating multiple scenarios where one person is leaning their head on the other's shoulder, lap, or chest. This pose should be used at most once, if at all. Your primary goal is to create maximum variety.

**CRITICAL RULE 2: FOCUS ON DIVERSE INTERACTIONS.** To ensure variety, pull inspiration from these creative categories:
*   **Playful Movement:** A candid moment of them dancing slowly, him spinning her gently, or sharing a spontaneous laugh.
*   **Shared Activities:** Them quietly reading a book together, sharing a single cup of coffee, or looking at something interesting just off-camera.
*   **Intimate Connection (without leaning):** Sitting back-to-back with eyes closed, him whispering something in her ear that makes her smile, or a gentle moment of him adjusting her hijab or a piece of her jewelry.
*   **Elegant Poses:** Standing poses like a gentle hug from behind, or them sitting apart on minimalist furniture but connected by their gaze.

**CRITICAL RULE 3: STORYTELLING.** Each scene must tell a small story. Avoid stiff "stand and smile" poses. Use light, shadow, and minimal props to enhance the mood.

**CRITICAL RULE 4: NO KISSING.** You are strictly forbidden from describing any form of kissing on the lips or face.

**OUTPUT FORMAT:** Output ONLY a valid JSON array of objects with "scene" and "emotion" keys. Do not include any other text or markdown.
Example: [{ "scene": "Sitting on the floor, they are both focused on a single book he is holding open, their shoulders lightly touching as they share a quiet, concentrated moment.", "emotion": "Shared intellectual intimacy." }]`;
        } else {
            prompt = `You are an elite photoshoot director. Generate ${count} unique, romantic, and story-driven photo scenarios for a photoshoot in "${locationTheme}".

**CRITICAL RULE 1: AVOID MONOTONY & LEANING POSES.** You are explicitly forbidden from generating scenarios where one person is leaning their head on the other's shoulder, lap, or chest. Your primary goal is to create maximum variety through diverse, story-driven interactions.

**CRITICAL RULE 2: FOCUS ON DIVERSE INTERACTIONS.** To ensure variety, describe creative actions like:
*   **Shared Activities:** Them quietly reading a book together, sharing a single cup of coffee, or looking at something interesting just off-camera.
*   **Playful Movement:** A candid moment of them dancing slowly, him spinning her gently, or sharing a spontaneous laugh.
*   **Intimate Connection (without leaning):** Sitting back-to-back with eyes closed, him whispering something in her ear that makes her smile, or a gentle moment of him adjusting her hijab or a piece of her jewelry.

**CRITICAL RULE 3: STORYTELLING & LOCATION.** Each scene must tell a small story. **If the location is a famous city or landmark (e.g., "Paris", "Tokyo", "Bromo"), the "scene" description MUST explicitly mention an iconic, recognizable landmark or feature of that location.** For example, for Tokyo, mention "Shibuya Crossing". For Paris, "Eiffel Tower". For Bromo, "the crater".

**CRITICAL RULE 4: NO KISSING.** You are strictly forbidden from describing any form of kissing on the lips or face.

**OUTPUT FORMAT:** Output ONLY a valid JSON array of objects with "scene" and "emotion" keys. Do not include any other text or markdown.
Example for Tokyo: [{ "scene": "Couple shares a candid laugh under an umbrella amidst the neon lights and bustling crowds of Shibuya Crossing at night.", "emotion": "Joyful connection in a vibrant city." }]`;
        }

        const ai = new GoogleGenAI({ apiKey });

        const response = await ai.models.generateContent({
            model: "gemini-2.5-flash",
            contents: prompt,
            config: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: Type.ARRAY,
                    items: {
                        type: Type.OBJECT,
                        properties: {
                            scene: { type: Type.STRING },
                            emotion: { type: Type.STRING },
                        },
                        required: ["scene", "emotion"],
                    },
                },
            },
        });
        
        const safetyBlockReason = checkForSafetyBlock(response);
        if (safetyBlockReason) {
            throw new Error(`SAFETY_BLOCK: ${safetyBlockReason}`);
        }

        const parsed = JSON.parse(response.text.trim());
        if (!Array.isArray(parsed) || parsed.length === 0) {
            throw new Error("Generated scenarios are not in the expected format or are empty.");
        }
        return parsed;
    } catch (error) {
        console.error("Error generating location scenarios:", error);
        if (error instanceof Error && error.message.startsWith('SAFETY_BLOCK:')) {
            throw error;
        }
        throw new Error(`Failed to generate scenarios: ${error instanceof Error ? error.message : String(error)}`);
    }
}

/**
 * Generates outfit ideas for a couple based on 'Adat' style. This is a local synchronous function.
 * @param outfitType Must be 'Adat'.
 * @param region Optional region for 'Adat' type.
 * @returns An array of OutfitIdea objects.
 */
export function generateOutfitIdeas(outfitType: 'Adat', region?: string): OutfitIdea[] {
    let inspirations = adatInspirations;
    
    if (region) {
        const specific = inspirations.find(i => i.region === region);
        inspirations = specific ? [specific] : [];
    }

    const allIdeas: OutfitIdea[] = [];
    inspirations.forEach(inspiration => {
        // Hijab version
        allIdeas.push({
            male: inspiration.groom,
            female: inspiration.bride_hijab,
            male_id: inspiration.groom_id,
            female_id: inspiration.bride_hijab_id,
            style: 'Berhijab'
        });
        // Non-hijab version
        allIdeas.push({
            male: inspiration.groom,
            female: inspiration.bride_nonhijab,
            male_id: inspiration.groom_id,
            female_id: inspiration.bride_nonhijab_id,
            style: 'Tanpa Hijab'
        });
    });

    return shuffleArray(allIdeas);
}

/**
 * Generates a creative brief for a photoshoot based on user's abstract inputs.
 * @param apiKey The API key to use.
 * @param keywords Three words describing the couple's relationship.
 * @param colorPalette A descriptive name of a color palette.
 * @param visualStyle A description of the desired visual style.
 * @returns A promise resolving to a CreativeBrief object.
 */
export async function generateCreativeBrief(apiKey: string, keywords: string[], colorPalette: string, visualStyle: string, womanStyle: 'Berhijab' | 'Tanpa Hijab'): Promise<CreativeBrief> {
    const prompt = `You are a world-class Creative Director with a human touch, tasked with inspiring a couple for their pre-wedding photoshoot. Your tone should be personal, warm, and creative. Based on the couple's abstract inputs, generate a "Creative Brief" as a JSON object.

Couple's Inputs:
- Relationship Keywords: ${keywords.join(', ')}
- Desired Color Palette: ${colorPalette}
- Desired Visual Style: ${visualStyle}
- Woman's Style: ${womanStyle}

Generate a structured JSON object with these exact keys:
1.  "conceptStory": (In Indonesian) Write a short, heartfelt, and personal story that captures the essence of their relationship. This should feel like a beautiful narrative, not a list of instructions.
2.  "locationTheme": (String) From this specific list, choose the ONE location theme that best fits the concept: ["Studio Minimalis (Latar Putih)", "Studio Konsep Bohemian", "Studio Tema Bunga & Tanaman", "Studio Industrial (Dinding Bata)", "Studio Konsep Rumahan (Cozy)", "Studio Tema Vintage & Retro", "Kehidupan Sehari-hari", "Kisah Kampus", "Pasar Tradisional", "Kota Tua", "Pedesaan", "Hutan Tropis", "Bali", "Yogyakarta", "Bromo", "Tokyo", "Kyoto", "Seoul (Korea)", "Paris", "Santorini", "London", "New York City"].
3.  "colorTone": (String) From this specific list, choose the ONE color tone that aligns with the visual style and palette: ["Cerah & Alami", "Hangat & Keemasan", "Hitam & Putih"].
4.  "initialPrompt": (In English) Create a poetic, detailed, and evocative initial prompt for an AI image generator. This prompt must describe a young Indonesian couple. The woman's style is "${womanStyle}", so if 'Berhijab', describe a stylish, modern hijab-friendly outfit. **Crucially, if the woman is wearing a hijab, create a contemporary look that is NOT a gamis or a single long dress.** Think in terms of stylish separates: a chic tunic with palazzo pants, a fashionable long-sleeved blouse with a flowing maxi skirt, or a coordinated set (co-ord). The hijab should be styled elegantly to match. If 'Tanpa Hijab', describe her beautiful hairstyle. **CRITICAL: The clothing must be stylish, photogenic, and reflect a modern 'smart casual' or 'bohemian chic' aesthetic. Emphasize natural fabrics like linen and cotton in earthy, soft, or neutral tones. For the man, think of outfits like a relaxed linen shirt with tailored chinos. For the woman, describe outfits like a flowing midi or maxi dress, a stylish linen blouse with wide-leg trousers, or a chic coordinated set. The outfits must look intentionally styled for a special occasion, yet feel relaxed and authentic. Absolutely forbid overly formal business suits, basic plain t-shirts, standard blue jeans, pajamas, or homewear.** The prompt should vividly describe the couple, their outfits, and a specific scene based on the concept story and location. It should be a complete paragraph ready for generation.

**CRITICAL: Output ONLY a valid JSON object. Do not include any other text, explanations, or markdown formatting.**`;

    const ai = new GoogleGenAI({ apiKey });
    const response = await ai.models.generateContent({
        model: "gemini-2.5-flash",
        contents: prompt,
        config: {
            responseMimeType: "application/json",
            responseSchema: {
                type: Type.OBJECT,
                properties: {
                    conceptStory: { type: Type.STRING },
                    locationTheme: { type: Type.STRING },
                    colorTone: { type: Type.STRING },
                    initialPrompt: { type: Type.STRING },
                },
                required: ["conceptStory", "locationTheme", "colorTone", "initialPrompt"],
            },
        },
    });

    const safetyBlockReason = checkForSafetyBlock(response);
    if (safetyBlockReason) {
        throw new Error(`SAFETY_BLOCK: ${safetyBlockReason}`);
    }

    const parsed: CreativeBrief = JSON.parse(response.text.trim());
    if (!parsed.conceptStory || !parsed.locationTheme || !parsed.colorTone || !parsed.initialPrompt) {
        throw new Error("Generated brief is not in the expected format or is missing fields.");
    }
    
    return parsed;
}

/**
 * Validates a single API key by making a simple, low-cost text generation request.
 * Differentiates between invalid keys and keys that have reached their rate limit.
 * @param apiKey The API key to validate.
 * @returns A promise that resolves to an ApiKeyStatus: 'active', 'invalid', or 'exhausted'.
 */
export async function validateApiKey(apiKey: string): Promise<ApiKeyStatus> {
    if (!apiKey || apiKey.trim() === '') {
        return 'invalid';
    }
    try {
        const ai = new GoogleGenAI({ apiKey });
        // Use a very minimal request to validate
        await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: 'hi',
            config: { thinkingConfig: { thinkingBudget: 0 } }
        });
        return 'active';
    } catch (error) {
        // FIX: Safely handle error of type 'unknown' in catch blocks and improve error message parsing.
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.error(`API key validation failed for key ending in ...${apiKey.slice(-4)}: ${errorMessage}`);
        
        if (errorMessage.includes('API key not valid')) {
            return 'invalid';
        }
        if (errorMessage.includes('429') || errorMessage.includes('RESOURCE_EXHAUSTED') || errorMessage.includes('rate limit')) {
            return 'exhausted';
        }
        
        // Treat other errors (network, etc.) as invalid for simplicity in the UI
        return 'invalid';
    }
}

/**
 * Takes a couple portrait and regenerates it with new outfits and a new pose, preserving faces and hair.
 * @param apiKey The API key to use.
 * @param referenceImage The combined couple image.
 * @returns A promise that resolves to a base64 encoded image URL of the re-styled portrait.
 */
export async function generateOutfitForJoinedCouple(apiKey: string, referenceImage: {base64: string, mimeType: string}): Promise<string> {
    try {
        const ai = new GoogleGenAI({ apiKey });

        const imagePart = { inlineData: { data: referenceImage.base64, mimeType: referenceImage.mimeType } };
        
        const textPart = {
            text: `**TECHNICAL TASK: OUTFIT REPLACEMENT WITH FORENSIC IDENTITY PRESERVATION. This is a non-creative, image processing instruction.**

**INPUT:** A single image of a couple.
**OUTPUT:** The identical image, but with the couple wearing new, stylish outfits.

**NON-NEGOTIABLE DIRECTIVES:**

1.  **DIRECTIVE 1: ABSOLUTE IDENTITY & POSE PRESERVATION (HIGHEST PRIORITY)**
    -   **COMMAND:** Perform a 1:1 digital replication of the subjects' **ENTIRE HEADS (face, hair, etc.), BODY SHAPE, and POSE** from the source image onto the final image.
    -   **TECHNICAL SPECIFICATION:** This is a data transfer, not an artistic interpretation. The faces, hair, and pose must be **forensically identical** to the source image. Every feature, proportion, skin tone, hair texture, and their exact positions must be preserved with **pixel-perfect accuracy**.
    -   **FAILURE CONDITION:** If the generated faces, hair, body shapes, or pose are not **perfectly and identically** the same as the source image, the entire task is a failure.

2.  **DIRECTIVE 2: OUTFIT REPLACEMENT (The ONLY Allowed Change)**
    -   **COMMAND:** After the subjects are perfectly replicated, "repaint" them with **NEW, STYLISH, MODERN outfits**. The goal is a contemporary, photogenic, pre-wedding look.
    -   **STRICTLY FORBIDDEN OUTFITS:** You are explicitly forbidden from generating:
        - For the woman: **Gamis, kaftan, abaya, or any single-piece long, loose traditional/religious dress.**
        - For the man: **Baju koko, peci, or overly simple t-shirts.**
        - For both: Standard office wear, basic jeans, or homewear.
    -   **MODERN STYLE INSPIRATION (Choose creatively from these aesthetics):**
        - **Bohemian Chic:** Flowing tiered maxi skirt with a fitted lace top, or an embroidered linen midi dress for her. Soft, unbuttoned camp-collar shirt over a plain tee with relaxed-fit cotton trousers for him.
        - **Smart Casual / Urban Sophisticate:** A stylish coordinated set (blazer and wide-leg trousers) in a pastel color, or a silk blouse tucked into tailored culottes for her. A sharp polo shirt with slim-fit chinos and loafers, or a lightweight knit sweater over a collared shirt for him.
        - **Minimalist Elegance:** A simple but well-cut slip dress made of satin, or a monochrome jumpsuit for her. A clean-lined mandarin collar shirt with dark, straight-leg trousers for him.
    -   **INSTRUCTION:** The new outfits must be a creative and complementary combination.

3.  **DIRECTIVE 3: BACKGROUND & LIGHTING PRESERVATION (Lowest Priority)**
    -   **COMMAND:** The background and lighting of the scene must remain **identical** to the original reference image.`
        };

        const response: GenerateContentResponse = await ai.models.generateContent({
            // FIX: Updated model name and responseModalities per Gemini API guidelines for image generation.
            model: 'gemini-2.5-flash-image',
            contents: { parts: [imagePart, textPart] },
            config: {
                responseModalities: [Modality.IMAGE],
            },
        });
        
        const safetyBlockReason = checkForSafetyBlock(response);
        if (safetyBlockReason) {
            throw new Error(`SAFETY_BLOCK: ${safetyBlockReason}`);
        }

        for (const part of response.candidates[0].content.parts) {
            if (part.inlineData && part.inlineData.mimeType.startsWith('image/')) {
                const base64ImageBytes: string = part.inlineData.data;
                const imageMimeType = part.inlineData.mimeType;
                return `data:${imageMimeType};base64,${base64ImageBytes}`;
            }
        }
        
        const errorText = response.text?.trim();
        if (errorText) {
            throw new Error(`API returned a text response instead of an image: ${errorText}`);
        }
        
        throw new Error('No image was generated by the API.');

    } catch (error) {
        console.error("Error generating outfit for joined couple with AI API:", error);
        if (error instanceof Error && error.message.startsWith('SAFETY_BLOCK:')) {
            throw error;
        }
        throw new Error(`Failed to generate outfit: ${error instanceof Error ? error.message : String(error)}`);
    }
}

/**
 * Takes a reference portrait and regenerates it with new outfits, preserving faces, pose, and background.
 * @param apiKey The API key to use.
 * @param referenceImage The source image to modify.
 * @param clothingDescription The text description of the new desired clothing.
 * @param womanStyle The user's style preference for the woman, to ensure consistency.
 * @returns A promise that resolves to a base64 encoded image URL of the re-styled portrait.
 */
export async function changeReferenceOutfit(apiKey: string, referenceImage: {base64: string, mimeType: string}, clothingDescription: string, womanStyle: WomanStyle): Promise<string> {
    try {
        const ai = new GoogleGenAI({ apiKey });

        const imagePart = { inlineData: { data: referenceImage.base64, mimeType: referenceImage.mimeType } };
        
        let styleModificationRule = '';
        switch (womanStyle) {
            case 'Berhijab':
                styleModificationRule = `
**WOMAN'S STYLE RULE (MANDATORY):** The woman in the final image **MUST** be wearing a stylish, modern hijab. This is a non-negotiable instruction.
- If the woman in the source image is NOT wearing a hijab, you are commanded to ADD a hijab that complements her new outfit.
- If the woman in the source image IS wearing a hijab, you must ensure she is still wearing a matching hijab in the final image.
- The style must be contemporary, not a traditional gamis.`;
                break;
            case 'Tanpa Hijab':
                styleModificationRule = `
**WOMAN'S STYLE RULE (MANDATORY):** The woman in the final image **MUST NOT** be wearing a hijab or any head covering. Her styled hair must be clearly visible. This is a non-negotiable instruction.
- If the woman in the source image IS wearing a head covering, you are commanded to REMOVE it and generate styled hair that matches her identity.`;
                break;
            case 'Referensi Photo':
            default:
                styleModificationRule = `
**WOMAN'S STYLE RULE (MANDATORY):** The woman's head/hair style in the final image **MUST BE IDENTICAL** to the source image.
- If she is wearing a hijab in the source, she must be wearing an identical one in the output.
- If her hair is showing in the source, her hair must be identical in the output.
- Do not add or remove any head coverings.`;
                break;
        }
        
        const textPart = {
            text: `**PRIMARY GOAL: OUTFIT REPLACEMENT & STUDIO BACKGROUND.**
**SECONDARY GOAL: PRESERVE IDENTITY AND POSE.**
This is a technical image processing task.

**STEP-BY-STEP EXECUTION PLAN (Strictly Follow):**

**1. ANALYZE WOMAN'S STYLE (CRITICAL FIRST STEP):**
${styleModificationRule}

**2. APPLY NEW OUTFITS:**
- Change the outfits based **strictly** on this description: "${clothingDescription}".
- During this step, you **MUST** simultaneously apply the style rule defined in Step 1.

**3. PRESERVE IDENTITY & POSE (NON-NEGOTIABLE):**
- The subjects' **FACES, HAIR (if visible), BODY SHAPE, and POSE** from the source image must be replicated with **FORENSIC 1:1 ACCURACY**. They must be identical to the source. This is a data transfer, not an artistic interpretation.

**4. REPLACE BACKGROUND (NON-NEGOTIABLE):**
- **COMMAND:** You **MUST** completely **REMOVE and REPLACE** the original background from the source image.
- **NEW BACKGROUND:** The subjects must be placed in a professional, minimalist photo studio. The background **MUST** be a seamless, neutral, medium-grey backdrop.
- **LIGHTING:** The lighting on the subjects must be soft, even, and flattering, as if from a large softbox placed slightly off-camera. This lighting should look professional and intentional for a studio portrait, harmonizing with the new studio background.

**FINAL CHECK (MANDATORY):** Does the final image perfectly match the source in identity and pose? Is the new outfit applied? Most importantly, is the background a neutral grey studio set as commanded, and does it follow the strict style rule from Step 1? If not, the task is a failure.`
        };

        const response: GenerateContentResponse = await ai.models.generateContent({
            // FIX: Updated model name and responseModalities per Gemini API guidelines for image generation.
            model: 'gemini-2.5-flash-image',
            contents: { parts: [imagePart, textPart] },
            config: {
                responseModalities: [Modality.IMAGE],
            },
        });
        
        const safetyBlockReason = checkForSafetyBlock(response);
        if (safetyBlockReason) {
            throw new Error(`SAFETY_BLOCK: ${safetyBlockReason}`);
        }

        for (const part of response.candidates[0].content.parts) {
            if (part.inlineData && part.inlineData.mimeType.startsWith('image/')) {
                const base64ImageBytes: string = part.inlineData.data;
                const imageMimeType = part.inlineData.mimeType;
                return `data:${imageMimeType};base64,${base64ImageBytes}`;
            }
        }
        
        const errorText = response.text?.trim();
        if (errorText) {
            throw new Error(`API returned a text response instead of an image: ${errorText}`);
        }
        
        throw new Error('No image was generated by the API.');

    } catch (error) {
        console.error("Error changing reference outfit with AI API:", error);
        if (error instanceof Error && error.message.startsWith('SAFETY_BLOCK:')) {
            throw error;
        }
        throw new Error(`Failed to change outfit: ${error instanceof Error ? error.message : String(error)}`);
    }
}

/**
 * Generates a detailed description of a virtual photo studio set.
 * @param apiKey The API key to use.
 * @param theme The theme of the studio (e.g., "Studio Minimalis").
 * @returns A promise resolving to the studio description string.
 */
export async function generateStudioSetDescription(apiKey: string, theme: string): Promise<string> {
    const prompt = `Generate a detailed and consistent description for a virtual photo studio set based on the theme: "${theme}".
Describe the following elements in a single, cohesive paragraph:
-   **Background:** The color and texture of the walls (e.g., "clean off-white walls with a subtle linen texture").
-   **Flooring:** The type and color of the floor (e.g., "polished light oak wood floors").
-   **Main Props/Furniture:** 2-3 key pieces of furniture or large props that define the space (e.g., "a minimalist beige sofa, a large potted monstera plant, and a brass floor lamp").
-   **Lighting Style:** The type of lighting (e.g., "soft, diffused light from a large, off-camera softbox, creating gentle shadows").
The description should be specific enough to be reused for multiple photos while allowing for different poses. Output ONLY the descriptive paragraph.`;
    return generateText(apiKey, prompt);
}

/**
 * Expands a simple location idea into a rich, descriptive prompt in English.
 * @param apiKey The API key to use.
 * @param themeIdea The user's simple location description.
 * @returns A promise that resolves to the enhanced, detailed prompt string in English.
 */
export async function enhanceLocationTheme(apiKey: string, themeIdea: string): Promise<string> {
    const prompt = `Take this simple location idea for a pre-wedding photoshoot and expand it into a rich, creative, and evocative scene description **in English**. This output will be used as a prompt for an AI image generator.

Focus on:
-   **Atmosphere & Mood:** Is it romantic, adventurous, serene, moody?
-   **Visual Details:** Describe specific elements like architecture, nature, textures.
-   **Lighting:** Is it golden hour, soft morning light, dramatic sunset, moody overcast?

User's idea: "${themeIdea}"

**Output ONLY the enhanced description as a single paragraph in English.**`;
    return generateText(apiKey, prompt);
}


/**
 * Generates a new photo based on reference images using a robust, single-step process.
 * This method prioritizes facial identity replication above all else within a single, powerful prompt.
 * @param apiKey The API key to use.
 * @param identityAnchors The source images of the couple.
 * @param details Object containing all creative details for the new scene.
 * @param locationAnchor An optional image to be used as the scene reference.
 * @returns A promise that resolves to a base64 encoded image URL of the new photo.
 */
export async function generatePhotoFromReference(
    apiKey: string,
    identityAnchors: IdentityAnchorFile[],
    details: GenerationDetails,
    locationAnchor?: IdentityAnchorFile | null
): Promise<string> {

    // Defensive check to prevent logic conflicts. If user explicitly wants to use reference photo's clothing,
    // ignore any clothingDescription that might have been passed by mistake.
    if (details.womanStyle === 'Referensi Photo' && details.clothingDescription) {
        console.warn("Logic conflict: 'Referensi Photo' style was chosen, but a clothing description was also provided. Prioritizing reference photo's clothing by ignoring the description.");
        details.clothingDescription = undefined;
    }

    const ai = new GoogleGenAI({ apiKey });

    const maleAnchors = identityAnchors.filter(a => a.subject === 'pria');
    const femaleAnchors = identityAnchors.filter(a => a.subject === 'wanita');
    const coupleAnchor = identityAnchors.find(a => a.subject === 'pasangan');

    const isSingleSubjectShot = details.cameraShot === 'Close-up Pria' || details.cameraShot === 'Close-up Wanita';

    if (isSingleSubjectShot) {
        const subject = details.cameraShot === 'Close-up Pria' ? 'Pria' : 'Wanita';
        const subjectPronoun = subject === 'Pria' ? 'his' : 'her';
        
        let subjectAnchors = subject === 'Pria' ? maleAnchors : femaleAnchors;

        // If no specific subject anchors are found, but a couple anchor exists, use that instead.
        if (subjectAnchors.length === 0 && coupleAnchor) {
            subjectAnchors = [coupleAnchor];
        }

        if (subjectAnchors.length === 0) {
            throw new Error(`Tidak ada foto referensi untuk ${subject} untuk membuat close-up.`);
        }

        const allSubjectAnchorParts = subjectAnchors.map(a => ({
            inlineData: { data: a.base64, mimeType: a.mimeType }
        }));

        const clothingDirective = details.clothingDescription 
            ? `- **CLOTHING:** The ${subject.toLowerCase()}'s outfit MUST strictly follow the ${subject.toLowerCase()}'s part of this description: "${details.clothingDescription}". Ignore the other person's clothing description.`
            : `- **CLOTHING SOURCE:** The ${subject.toLowerCase()}'s clothing MUST be an identical replication of the outfit shown in ${subjectPronoun} primary 'depan' (front-facing) reference photo.`;
            
        const sceneAndEmotionDirective = `- **SCENE & POSE (CLOSE-UP OVERRIDE):** The subject is posing for a classic, intimate portrait. They are **looking directly at the camera** with a calm, gentle expression. The background is simple and beautifully out of focus (heavy bokeh). This instruction overrides any conflicting scene or emotion descriptions from other parts of the prompt.`;

        const masterPrompt = `**HIGHEST PRIORITY DIRECTIVE: SINGLE SUBJECT CLOSE-UP & IDENTITY REPLICATION**
**CAMERA SHOT (NON-NEGOTIABLE):** Generate a tight **CLOSE-UP PORTRAIT** of a single subject, the **${subject.toUpperCase()}**. The frame **MUST** be cropped from the **SHOULDERS UP**, focusing exclusively on the subject's face and upper shoulders. It is **STRICTLY FORBIDDEN** to show their chest, waist, or any part of the body below the shoulders. The subject **MUST be looking directly at the camera**. The background must be very blurry (bokeh).

**IDENTITY (CRITICAL):**
- Replicate the **${subject.toUpperCase()}'s** face, hair, skin tone, and build with **FORENSIC 1:1 ACCURACY** from the provided Identity Anchor photos.

**SECONDARY DIRECTIVE: SCENE & OUTFIT CONSTRUCTION**
${clothingDirective}
${sceneAndEmotionDirective}
${details.styleAndColorInstruction}
- **DSLR Quality:** Maintain ultra-sharp, professional DSLR quality.

**EXECUTION & FINAL VERIFICATION (MANDATORY)**
Generate an image of **ONLY ONE PERSON, the ${subject.toUpperCase()}**. Verify the framing is a perfect shoulder-up close-up, the subject is **looking directly at the camera**, and the face is a 1:1 match to the anchors.
${details.negativePromptInstruction}`;

        const response = await ai.models.generateContent({
            // FIX: Updated model name and responseModalities per Gemini API guidelines for image generation.
            model: 'gemini-2.5-flash-image',
            contents: {
                parts: [
                    ...allSubjectAnchorParts,
                    { text: masterPrompt }
                ]
            },
            config: { responseModalities: [Modality.IMAGE] },
        });

        const safetyBlockReason = checkForSafetyBlock(response);
        if (safetyBlockReason) throw new Error(`SAFETY_BLOCK: ${safetyBlockReason}`);

        const imagePart = response.candidates?.[0]?.content?.parts.find(p => p.inlineData && p.inlineData.mimeType.startsWith('image/'));
        if (imagePart?.inlineData) {
            return `data:${imagePart.inlineData.mimeType};base64,${imagePart.inlineData.data}`;
        } else {
            const errorText = response.text?.trim();
            if (errorText) throw new Error(`API returned text instead of an image: ${errorText}`);
            throw new Error('API failed to generate the single subject image.');
        }
    }

    // --- Logic for Couple Shots ---
    const allAnchorParts = identityAnchors.map(a => ({
        inlineData: { data: a.base64, mimeType: a.mimeType }
    }));
    
    if (locationAnchor) {
        allAnchorParts.unshift({ inlineData: { data: locationAnchor.base64, mimeType: locationAnchor.mimeType } });
    }

    const cameraShotDirective = (() => {
        switch (details.cameraShot) {
            case 'Close-up':
                return `**CAMERA SHOT (NON-NEGOTIABLE FRAMING):** Generate a **MEDIUM SHOT (WAIST UP)**. The frame **MUST capture the couple from their WAIST UP to the top of their heads.** This is a strict command. Ensure their entire heads, necks, shoulders, arms, and torsos are fully visible. **CRITICAL: Provide ample headroom and space on the sides of the subjects** to create a comfortable composition and absolutely prevent any part of their bodies from being cropped. The background must be beautifully out of focus (bokeh). This framing ensures both subjects are clearly and completely visible with a noticeable distance from the camera.`;
            case 'Medium Shot':
                return `**CAMERA SHOT (NON-NEGOTIABLE FRAMING):** Generate a **MEDIUM SHOT**. The frame **MUST BE CROPPED TIGHTLY AROUND THE COUPLE'S WAIST**. The final image must only show the couple from their **waist to the top of their heads**. It is **STRICTLY FORBIDDEN** to show their knees, shins, feet, or the floor beneath them. Any part of the body below the waist is forbidden. This is a technical command, not a creative suggestion. Failure to frame this as a waist-up shot is a task failure.`;
            case 'Full Body Shot':
            default:
                return `**CAMERA SHOT (HIGHEST FRAMING PRIORITY):** Generate a **FULL BODY SHOT**. The couple's **ENTIRE body, from head to toe, MUST be visible within the frame.** Ensure the subjects' feet are not cut off by the frame and include enough background to provide context to the scene. Their complete outfits and their immediate surroundings must be visible. This is a strict framing instruction.`;
        }
    })();
    
    let clothingInstruction = '';
    let referenceModification = '';

    if (details.clothingDescription) {
        clothingInstruction = `The couple's clothing MUST strictly follow this description: "${details.clothingDescription}". Do not use clothing from any reference image.`;
    } else {
        clothingInstruction = `The couple's clothing MUST be an identical replication of the outfits shown in the primary 'depan' (front-facing) reference photos. If side-view photos show different clothing, IGNORE the clothing from the side-view photos. The front-view photo is the single source of truth for outfits.`;

        if (details.womanStyle === 'Berhijab') {
            referenceModification = `**STYLE MODIFICATION:** The woman must now be wearing a stylish, modern hijab that complements her outfit. If the outfit in the reference photo is not suitable for a hijab (e.g., sleeveless), modify it to be hijab-friendly (e.g., by adding long sleeves) while maintaining its overall style and color. Ensure the final look is contemporary and not a traditional gamis.`;
        } else if (details.womanStyle === 'Tanpa Hijab') {
            referenceModification = `**STYLE MODIFICATION:** If the woman in the reference photo is wearing any form of head covering (like a hijab), she must now be shown without it, with her styled hair clearly visible. This is a direct instruction to remove the head covering.`;
        } else if (details.womanStyle === 'Referensi Photo') {
            referenceModification = `**STYLE MODIFICATION (CRITICAL):** The woman's head and hair/hijab style **MUST BE IDENTICAL** to her appearance in the reference photos. If she is wearing a hijab in the reference, she must wear an identical one. If her hair is showing, it must be identical. **DO NOT ADD, REMOVE, OR CHANGE HER HEADWEAR OR HAIRSTYLE in any way.** This is a strict replication command.`;
        }
    }
    
    let sceneAndBodyInstruction: string;
    let wardrobeStepNumber = 3;

    if (details.cameraShot === 'Close-up') {
        sceneAndBodyInstruction = `1.  **BODY BUILD & POSE (MEDIUM SHOT OVERRIDE):**
    - **BODY BUILD:** Replicate the subjects' upper body builds and proportions from the reference photos.
    - **POSE (NON-NEGOTIABLE):**
        - **POSITIONING:** The couple **MUST be standing or sitting SIDE-BY-SIDE on the same plane**. They should be at a similar distance from the camera.
        - **ORIENTATION:** Both subjects' bodies **MUST face forward** towards the camera.
        - **PROHIBITED POSE:** You are **STRICTLY FORBIDDEN** from creating a pose where one person stands behind the other, leans over the other's shoulder, or places a hand on the other's shoulder/chest.
        - **INTERACTION:** Their interaction must be natural for a side-by-side pose. They can be holding hands, or have their arms loosely around each other's waist or back, or simply standing close with shoulders nearly touching. Their expressions must be relaxed and connected.
    - **SCENE & EMOTION:** The background is a simple, out-of-focus (bokeh) backdrop. This instruction overrides any other conflicting pose or scene descriptions.`;
        wardrobeStepNumber = 2; // Wardrobe is the next step
    } else {
        const sceneInstruction = locationAnchor
            ? `The entire scene, background, and environment **MUST be an identical, 1:1 replication of the provided location reference image.** Place the couple naturally within this exact scene.`
            : details.studioDescription
                ? `The scene is a pre-defined studio set with the following characteristics: "${details.studioDescription}". Within this studio, the couple's action is: "${details.scenarioScene}".`
                : details.scenarioScene;
        
        sceneAndBodyInstruction = `1.  **BODY & POSE:** **DO NOT simply copy the pose from the reference image.** Instead, create a **NEW, creative, and natural pose** based on the action described in the 'SCENE & EMOTION' step below. Replicate the body shapes and proportions from the reference images, but place them into this new, dynamic pose. **CRITICAL POSE GUIDELINE: To ensure facial features are accurately replicated, the new pose should have BOTH subjects looking towards the camera or engaging in a way that their faces are clearly and frontally visible.** Avoid side profiles or poses where faces are obscured.
2.  **SCENE & EMOTION:** Place the perfectly replicated couple into this new scene: ${sceneInstruction}. Their expressions should reflect this emotion, but **without altering their core facial features from STEP 1**: "${details.scenarioEmotion}".`;
    }

    const masterPrompt = `**TECHNICAL DIRECTIVE: IMAGE COMPOSITING VIA IDENTITY GRAFTING**
This is a technical image processing task. The final image must be a photorealistic, 4k cinematic photo.

**CRITICAL COMPOSITION CONSTRAINT: SUBJECT COUNT (ABSOLUTE RULE)**
- The final output image **MUST** contain **EXACTLY TWO (2) HUMAN SUBJECTS**: one (1) male and one (1) female, forming a couple.
- The presence of any additional people (a third person, a crowd, figures in the background, etc.) is a **CATASTROPHIC FAILURE** of this task. This is a non-negotiable rule.

**PRIMARY GOAL (NON-NEGOTIABLE):** The absolute, highest priority is the 1:1 replication of the human subjects' heads from the reference photos onto a new scene.

**//== STEP 1: FORENSIC IDENTITY GRAFTING (ABSOLUTE HIGHEST PRIORITY) ==//**

**COMMAND:**
1.  **IDENTIFY** the two human subjects in all provided reference images: one male (**MAN**) and one female (**WOMAN**).
2.  **EXTRACT** the complete head data for BOTH the **MAN** and the **WOMAN**. This includes their **exact facial features, facial structure, skin tone, and hair/hijab style.**
3.  **GRAFT** these perfectly extracted heads onto the subjects in the final generated image. This is a data transfer, not an artistic interpretation.

**MANDATORY VERIFICATION & FAILURE CONDITION:**
- The **MAN's** head in the output (face, hair, skin tone) **MUST** be a perfect, 1:1, forensically identical copy of the man in the reference images.
- The **WOMAN's** head in the output (face, hair/hijab, skin tone) **MUST** be a perfect, 1:1, forensically identical copy of the woman in the reference images.
- If **EITHER** head deviates in **ANY** way from the source material, the entire generation is considered a **CATASTROPHIC FAILURE**. **ZERO DEVIATION IS PERMITTED.** This rule overrides all other creative instructions.

**//== STEP 2: SCENE & BODY CONSTRUCTION (EXECUTE ONLY AFTER STEP 1 IS PERFECT) ==//**

**COMMAND:** Only after the identity graft is guaranteed, construct the rest of the image.
${sceneAndBodyInstruction}
${wardrobeStepNumber}.  **WARDROBE & STYLE:** Dress the subjects according to these rules:
    - **Clothing:** ${clothingInstruction}
    - **Style Modification (if any):** ${referenceModification}
${wardrobeStepNumber + 1}.  **COMPOSITION & QUALITY:**
    - **Framing:** ${cameraShotDirective}
    - **Style:** ${details.styleAndColorInstruction}. Maintain ultra-sharp, professional DSLR quality.
    - **Prohibited:** ${details.negativePromptInstruction}

**//== FINAL CHECK ==//**
Before outputting, perform a final verification:
1.  **Identity Check:** Are the heads of **BOTH** subjects forensically identical to the source references?
2.  **Subject Count Check:** Does the image contain **EXACTLY TWO PEOPLE**?
If the answer to either question is no, the task has failed.`;

    try {
        const response = await ai.models.generateContent({
            // FIX: Updated model name and responseModalities per Gemini API guidelines for image generation.
            model: 'gemini-2.5-flash-image',
            contents: {
                parts: allAnchorParts.length > 0 ? [
                    ...allAnchorParts,
                    { text: masterPrompt }
                ] : [{text: masterPrompt}] // Handle case with no anchors but location anchor might exist
            },
            config: { responseModalities: [Modality.IMAGE] },
        });

        const safetyBlockReason = checkForSafetyBlock(response);
        if (safetyBlockReason) throw new Error(`SAFETY_BLOCK: ${safetyBlockReason}`);

        const imagePart = response.candidates?.[0]?.content?.parts.find(p => p.inlineData && p.inlineData.mimeType.startsWith('image/'));
        if (imagePart?.inlineData) {
            const finalBase64 = imagePart.inlineData.data;
            const finalMimeType = imagePart.inlineData.mimeType;
            return `data:${finalMimeType};base64,${finalBase64}`;
        } else {
            const errorText = response.text?.trim();
            if (errorText) {
                throw new Error(`API returned text instead of an image: ${errorText}`);
            }
            throw new Error('API failed to generate the final image.');
        }
    } catch (error) {
        console.error("Image Generation failed:", error);
        throw new Error(`Gagal menghasilkan gambar: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
}